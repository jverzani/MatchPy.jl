<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MatchPy.jl · MatchPy Documentation</title><meta name="title" content="MatchPy.jl · MatchPy Documentation"/><meta property="og:title" content="MatchPy.jl · MatchPy Documentation"/><meta property="twitter:title" content="MatchPy.jl · MatchPy Documentation"/><meta name="description" content="Documentation for MatchPy Documentation."/><meta property="og:description" content="Documentation for MatchPy Documentation."/><meta property="twitter:description" content="Documentation for MatchPy Documentation."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">MatchPy Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href="index.html">MatchPy.jl</a><ul class="internal"><li><a class="tocitem" href="#Interface"><span>Interface</span></a></li><li><a class="tocitem" href="#Wildcards"><span>Wildcards</span></a></li><li><a class="tocitem" href="#Differences"><span>Differences</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="index.html">MatchPy.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="index.html">MatchPy.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jverzani/MatchPy.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jverzani/MatchPy.jl/blob/master/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="MatchPy.jl"><a class="docs-heading-anchor" href="#MatchPy.jl">MatchPy.jl</a><a id="MatchPy.jl-1"></a><a class="docs-heading-anchor-permalink" href="#MatchPy.jl" title="Permalink"></a></h1><p>This package provides two matching algorithms.</p><ul><li><p>An implementation of the algorithm of <a href="https://arxiv.org/abs/1705.00907">Non-linear Associative-Commutative Many-to-One Pattern Matching with Sequence Variables</a> by Manuel Krebber through Chapter 3, referred to as <code>MatchPy</code>.</p></li><li><p>A slight modification of a matching algorithm developed in the <code>SymbolicIntegration</code> package in <a href="https://github.com/JuliaSymbolics/SymbolicIntegration.jl/blob/main/src/methods/rule_based/rule2.jl">rule2.jl</a>. This implementation only depends on the lightweight <code>TermInterface</code> package and the <code>Combinatorics</code> package.</p></li></ul><p>Both find all matches of a pattern employing wildcards against a subject. The patterns are specified with Julia expressions. The latter algorithm allocates much less and is generally an order faster.</p><h2 id="Interface"><a class="docs-heading-anchor" href="#Interface">Interface</a><a id="Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Interface" title="Permalink"></a></h2><p>The choice of which algorithm is specified by <code>MatchPy.R2()</code> (the default) or <code>MatchPy.MP()</code>. The matchpy algorithm returns a generator which can be collected.</p><p>The <code>MatchPy._match</code> method chooses the first of the possible matches given by <code>_eachmatch</code>, returning <code>nothing</code> if there are no matches.</p><p>The <code>MatchPy._replace</code> method can be used to replace parts of an expression with other parts.</p><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><p>&quot;Each&quot; match</p><pre><code class="nohighlight hljs">julia&gt; using MatchPy

julia&gt; MatchPy._eachmatch(:(~x + ~y), :(a + b))
2-element Vector{Base.ImmutableDict{Symbol, Any}}:
 Base.ImmutableDict(:y =&gt; :b, :x =&gt; :a)
 Base.ImmutableDict(:y =&gt; :a, :x =&gt; :b)

julia&gt; MatchPy._eachmatch(:(~x + ~y), :(a + b), MatchPy.MP()) |&gt; collect
2-element Vector{Base.ImmutableDict{Symbol, Any}}:
 Base.ImmutableDict(:x =&gt; :b, :y =&gt; :a)
 Base.ImmutableDict(:x =&gt; :a, :y =&gt; :b)</code></pre><p>Single match</p><pre><code class="nohighlight hljs">julia&gt; MatchPy._match(:(~x + ~y), :(a + b), MatchPy.MP())
Base.ImmutableDict{Symbol, Any} with 2 entries:
  :x =&gt; :b
  :y =&gt; :a</code></pre><p>Replace:</p><pre><code class="nohighlight hljs">julia&gt; MatchPy._replace(:(cos(2x)^2 + sin(2x)^2), :(sin(~x)^2 + cos(~x)^2) =&gt; 1)
1</code></pre><h2 id="Wildcards"><a class="docs-heading-anchor" href="#Wildcards">Wildcards</a><a id="Wildcards-1"></a><a class="docs-heading-anchor-permalink" href="#Wildcards" title="Permalink"></a></h2><p>Patterns are specified with wildcards or which there is a variety. We follow the specification of <code>SymbolicUtils</code>.</p><ul><li><p>A &quot;slot variable&quot;, specified as <code>:(~x)</code>, matches one argument.</p></li><li><p>A &quot;default slot variable&quot;, specified <code>:(~!x)</code>, matches 0 or 1 arguments. First, a slot variable is replaced to see if there is a match. If there is none, an attempt to find a match with the variable replaced by a default value (for an operation of <code>+</code> this is <code>0</code>, for <code>*</code> this is <code>1</code>, and for an exponent, also <code>1</code>.</p></li><li><p>A &quot;segment variable&quot;, specified <code>:(~~x)</code>, matches 0, 1 or more of the arguments. The match is returned as a tuple of matches.</p></li></ul><p>In addition, for the MatchPy algorithm there is:</p><ul><li>A &quot;plus variable&quot;, specified as <code>:(~~~x)</code>, matches 1 or more of the arguments similar to a segment variable.</li></ul><p>Wildcards may have predicates attached to them through the notation <code>:(~x::predicate)</code>.</p><h3 id="Examples-2"><a class="docs-heading-anchor" href="#Examples-2">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-2" title="Permalink"></a></h3><ul><li>Use of default slots</li></ul><pre><code class="nohighlight hljs">juliaMatchPy._replace(:(2cos(2x)^2 + 2sin(2x)^2), :(~!a * sin(~x)^2 + ~!a * cos(~x)^2) =&gt; :(~!a))
2

julia&gt; MatchPy._eachmatch(:(~!a * sin(~!b *~x + ~!c)^(~!m)), :(sin(2x)))
2-element Vector{Base.ImmutableDict{Symbol, Any}}:
 Base.ImmutableDict(:a =&gt; 1, :m =&gt; 1, :c =&gt; 0, :x =&gt; :x, :b =&gt; 2)
 Base.ImmutableDict(:a =&gt; 1, :m =&gt; 1, :c =&gt; 0, :x =&gt; 2, :b =&gt; :x)</code></pre><ul><li>Use of predicate</li></ul><pre><code class="nohighlight hljs">julia&gt; MatchPy._eachmatch(:(~!a * sin(~!b *~x::(u -&gt; !isa(u,Number)) + ~!c)^(~!m)), :(sin(2x)))
1-element Vector{Base.ImmutableDict{Symbol, Any}}:
 Base.ImmutableDict(:a =&gt; 1, :m =&gt; 1, :c =&gt; 0, :x =&gt; :x, :b =&gt; 2)</code></pre><ul><li>Use of segment variable</li></ul><pre><code class="nohighlight hljs">julia&gt; MatchPy._eachmatch(:(~x + ~~y), :(a + b), MatchPy.MP()) |&gt; collect
3-element Vector{Base.ImmutableDict{Symbol, Any}}:
 Base.ImmutableDict(:x =&gt; :(a + b), :y =&gt; missing)
 Base.ImmutableDict(:x =&gt; :b, :y =&gt; :a)
 Base.ImmutableDict(:x =&gt; :a, :y =&gt; :b)</code></pre><ul><li>Plus variable must have aleast one match</li></ul><pre><code class="nohighlight hljs">julia&gt; MatchPy._eachmatch(:(~x + ~~~y), :(a + b), MatchPy.MP()) |&gt; collect
2-element Vector{Base.ImmutableDict{Symbol, Any}}:
 Base.ImmutableDict(:x =&gt; :b, :y =&gt; :a)
 Base.ImmutableDict(:x =&gt; :a, :y =&gt; :b)</code></pre><h2 id="Differences"><a class="docs-heading-anchor" href="#Differences">Differences</a><a id="Differences-1"></a><a class="docs-heading-anchor-permalink" href="#Differences" title="Permalink"></a></h2><p>The algorithms don&#39;t always give the same output. Here the segment variable for one is a tuple, but the MatchPy algorithm calls the <code>+</code> operation on the tuple, defaulting to <code>missing</code> when there are no arguments.</p><pre><code class="nohighlight hljs">julia&gt; MatchPy._eachmatch(:(~x + ~~y), :(+(a,b)))
3-element Vector{Base.ImmutableDict{Symbol, Any}}:
 Base.ImmutableDict(:y =&gt; (:b,), :x =&gt; :a)
 Base.ImmutableDict(:y =&gt; (:a,), :x =&gt; :b)
 Base.ImmutableDict(:x =&gt; :(a + b), :y =&gt; ())

julia&gt; MatchPy._eachmatch(:(~x + ~~y), :(+(a,b)), MatchPy.MP()) |&gt; collect
3-element Vector{Base.ImmutableDict{Symbol, Any}}:
 Base.ImmutableDict(:x =&gt; :(a + b), :y =&gt; missing)
 Base.ImmutableDict(:x =&gt; :b, :y =&gt; :a)
 Base.ImmutableDict(:x =&gt; :a, :y =&gt; :b)</code></pre><p>The expectations aren&#39;t the same either. For segment variables, MatchPy will try to identify all possibilities. Further, MatchPy has checks for <em>associativity</em> and <em>commutativity</em> and will call the operation on the identified matches, <code>R2</code> only checks commutativity. But more importantly, doesn&#39;t try to identify all possible matches when there are two segment variables. We can see this with this example:</p><pre><code class="nohighlight hljs">julia&gt; MatchPy._eachmatch(:(~~x + ~~y), :(a + b + c), MatchPy.MP()) |&gt; collect
8-element Vector{Base.ImmutableDict{Symbol, Any}}:
 Base.ImmutableDict(:x =&gt; :(a + b + c), :y =&gt; missing)
 Base.ImmutableDict(:x =&gt; :(b + c), :y =&gt; :a)
 Base.ImmutableDict(:x =&gt; :(a + c), :y =&gt; :b)
 Base.ImmutableDict(:x =&gt; :c, :y =&gt; :(a + b))
 Base.ImmutableDict(:x =&gt; :(a + b), :y =&gt; :c)
 Base.ImmutableDict(:x =&gt; :b, :y =&gt; :(a + c))
 Base.ImmutableDict(:x =&gt; :a, :y =&gt; :(b + c))
 Base.ImmutableDict(:x =&gt; missing, :y =&gt; :(a + b + c))

julia&gt; MatchPy._eachmatch(:(~~x + ~~y), :(a + b + c), MatchPy.R2())
1-element Vector{Base.ImmutableDict{Symbol, Any}}:
 Base.ImmutableDict(:y =&gt; (), :x =&gt; (:a, :b, :c))
 ```

 Similarly:

 ```
julia&gt; MatchPy._eachmatch(:(f(~~x, ~~y)), :(f(a,b,c)), MatchPy.MP()) |&gt; collect
4-element Vector{Base.ImmutableDict{Symbol, Any}}:
 Base.ImmutableDict(:y =&gt; Any[], :x =&gt; Any[:a, :b, :c])
 Base.ImmutableDict(:y =&gt; Any[:c], :x =&gt; Any[:a, :b])
 Base.ImmutableDict(:y =&gt; Any[:b, :c], :x =&gt; Any[:a])
 Base.ImmutableDict(:y =&gt; Any[:a, :b, :c], :x =&gt; Any[])

julia&gt; MatchPy._eachmatch(:(f(~~x, ~~y)), :(f(a,b,c)), MatchPy.R2())
1-element Vector{Base.ImmutableDict{Symbol, Any}}:
 Base.ImmutableDict(:y =&gt; (), :x =&gt; (:a, :b, :c))</code></pre><p>This is not quite the same as the last example, as <code>f</code> is not assumed associative and commutative (like <code>+</code>), so there are half as many matches.</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 27 January 2026 13:40">Tuesday 27 January 2026</span>. Using Julia version 1.12.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
