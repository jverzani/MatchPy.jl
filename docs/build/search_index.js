var documenterSearchIndex = {"docs":
[{"location":"index.html#MatchPy.jl","page":"MatchPy.jl","title":"MatchPy.jl","text":"This package provides two matching algorithms.\n\nAn implementation of the algorithm of Non-linear Associative-Commutative Many-to-One Pattern Matching with Sequence Variables by Manuel Krebber through Chapter 3, referred to as MatchPy.\nA slight modification of a matching algorithm developed in the SymbolicIntegration package in rule2.jl. This implementation only depends on the lightweight TermInterface package and the Combinatorics package.\n\nBoth find all matches of a pattern employing wildcards against a subject. The patterns are specified with Julia expressions. The latter algorithm allocates much less and is generally an order faster.","category":"section"},{"location":"index.html#Interface","page":"MatchPy.jl","title":"Interface","text":"The choice of which algorithm is specified by MatchPy.R2() (the default) or MatchPy.MP(). The matchpy algorithm returns a generator which can be collected.\n\nThe MatchPy._match method chooses the first of the possible matches given by _eachmatch, returning nothing if there are no matches.\n\nThe MatchPy._replace method can be used to replace parts of an expression with other parts.","category":"section"},{"location":"index.html#Examples","page":"MatchPy.jl","title":"Examples","text":"\"Each\" match\n\njulia> using MatchPy\n\njulia> MatchPy._eachmatch(:(~x + ~y), :(a + b))\n2-element Vector{Base.ImmutableDict{Symbol, Any}}:\n Base.ImmutableDict(:y => :b, :x => :a)\n Base.ImmutableDict(:y => :a, :x => :b)\n\njulia> MatchPy._eachmatch(:(~x + ~y), :(a + b), MatchPy.MP()) |> collect\n2-element Vector{Base.ImmutableDict{Symbol, Any}}:\n Base.ImmutableDict(:x => :b, :y => :a)\n Base.ImmutableDict(:x => :a, :y => :b)\n\nSingle match\n\njulia> MatchPy._match(:(~x + ~y), :(a + b), MatchPy.MP())\nBase.ImmutableDict{Symbol, Any} with 2 entries:\n  :x => :b\n  :y => :a\n\nReplace:\n\njulia> MatchPy._replace(:(cos(2x)^2 + sin(2x)^2), :(sin(~x)^2 + cos(~x)^2) => 1)\n1","category":"section"},{"location":"index.html#Wildcards","page":"MatchPy.jl","title":"Wildcards","text":"Patterns are specified with wildcards or which there is a variety. We follow the specification of SymbolicUtils.\n\nA \"slot variable\", specified as :(~x), matches one argument.\nA \"default slot variable\", specified :(~!x), matches 0 or 1 arguments. First, a slot variable is replaced to see if there is a match. If there is none, an attempt to find a match with the variable replaced by a default value (for an operation of + this is 0, for * this is 1, and for an exponent, also 1.\nA \"segment variable\", specified :(~~x), matches 0, 1 or more of the arguments. The match is returned as a tuple of matches.\n\nIn addition, for the MatchPy algorithm there is:\n\nA \"plus variable\", specified as :(~~~x), matches 1 or more of the arguments similar to a segment variable.\n\nWildcards may have predicates attached to them through the notation :(~x::predicate).","category":"section"},{"location":"index.html#Examples-2","page":"MatchPy.jl","title":"Examples","text":"Use of default slots\n\njuliaMatchPy._replace(:(2cos(2x)^2 + 2sin(2x)^2), :(~!a * sin(~x)^2 + ~!a * cos(~x)^2) => :(~!a))\n2\n\njulia> MatchPy._eachmatch(:(~!a * sin(~!b *~x + ~!c)^(~!m)), :(sin(2x)))\n2-element Vector{Base.ImmutableDict{Symbol, Any}}:\n Base.ImmutableDict(:a => 1, :m => 1, :c => 0, :x => :x, :b => 2)\n Base.ImmutableDict(:a => 1, :m => 1, :c => 0, :x => 2, :b => :x)\n\nUse of predicate\n\njulia> MatchPy._eachmatch(:(~!a * sin(~!b *~x::(u -> !isa(u,Number)) + ~!c)^(~!m)), :(sin(2x)))\n1-element Vector{Base.ImmutableDict{Symbol, Any}}:\n Base.ImmutableDict(:a => 1, :m => 1, :c => 0, :x => :x, :b => 2)\n\nUse of segment variable\n\njulia> MatchPy._eachmatch(:(~x + ~~y), :(a + b), MatchPy.MP()) |> collect\n3-element Vector{Base.ImmutableDict{Symbol, Any}}:\n Base.ImmutableDict(:x => :(a + b), :y => missing)\n Base.ImmutableDict(:x => :b, :y => :a)\n Base.ImmutableDict(:x => :a, :y => :b)\n\nPlus variable must have aleast one match\n\njulia> MatchPy._eachmatch(:(~x + ~~~y), :(a + b), MatchPy.MP()) |> collect\n2-element Vector{Base.ImmutableDict{Symbol, Any}}:\n Base.ImmutableDict(:x => :b, :y => :a)\n Base.ImmutableDict(:x => :a, :y => :b)","category":"section"},{"location":"index.html#Differences","page":"MatchPy.jl","title":"Differences","text":"The algorithms don't always give the same output. Here the segment variable for one is a tuple, but the MatchPy algorithm calls the + operation on the tuple, defaulting to missing when there are no arguments.\n\njulia> MatchPy._eachmatch(:(~x + ~~y), :(+(a,b)))\n3-element Vector{Base.ImmutableDict{Symbol, Any}}:\n Base.ImmutableDict(:y => (:b,), :x => :a)\n Base.ImmutableDict(:y => (:a,), :x => :b)\n Base.ImmutableDict(:x => :(a + b), :y => ())\n\njulia> MatchPy._eachmatch(:(~x + ~~y), :(+(a,b)), MatchPy.MP()) |> collect\n3-element Vector{Base.ImmutableDict{Symbol, Any}}:\n Base.ImmutableDict(:x => :(a + b), :y => missing)\n Base.ImmutableDict(:x => :b, :y => :a)\n Base.ImmutableDict(:x => :a, :y => :b)\n\nThe expectations aren't the same either. For segment variables, MatchPy will try to identify all possibilities. Further, MatchPy has checks for associativity and commutativity and will call the operation on the identified matches, R2 only checks commutativity. But more importantly, doesn't try to identify all possible matches when there are two segment variables. We can see this with this example:\n\njulia> MatchPy._eachmatch(:(~~x + ~~y), :(a + b + c), MatchPy.MP()) |> collect\n8-element Vector{Base.ImmutableDict{Symbol, Any}}:\n Base.ImmutableDict(:x => :(a + b + c), :y => missing)\n Base.ImmutableDict(:x => :(b + c), :y => :a)\n Base.ImmutableDict(:x => :(a + c), :y => :b)\n Base.ImmutableDict(:x => :c, :y => :(a + b))\n Base.ImmutableDict(:x => :(a + b), :y => :c)\n Base.ImmutableDict(:x => :b, :y => :(a + c))\n Base.ImmutableDict(:x => :a, :y => :(b + c))\n Base.ImmutableDict(:x => missing, :y => :(a + b + c))\n\njulia> MatchPy._eachmatch(:(~~x + ~~y), :(a + b + c), MatchPy.R2())\n1-element Vector{Base.ImmutableDict{Symbol, Any}}:\n Base.ImmutableDict(:y => (), :x => (:a, :b, :c))\n ```\n\n Similarly:\n\n ```\njulia> MatchPy._eachmatch(:(f(~~x, ~~y)), :(f(a,b,c)), MatchPy.MP()) |> collect\n4-element Vector{Base.ImmutableDict{Symbol, Any}}:\n Base.ImmutableDict(:y => Any[], :x => Any[:a, :b, :c])\n Base.ImmutableDict(:y => Any[:c], :x => Any[:a, :b])\n Base.ImmutableDict(:y => Any[:b, :c], :x => Any[:a])\n Base.ImmutableDict(:y => Any[:a, :b, :c], :x => Any[])\n\njulia> MatchPy._eachmatch(:(f(~~x, ~~y)), :(f(a,b,c)), MatchPy.R2())\n1-element Vector{Base.ImmutableDict{Symbol, Any}}:\n Base.ImmutableDict(:y => (), :x => (:a, :b, :c))\n\nThis is not quite the same as the last example, as f is not assumed associative and commutative (like +), so there are half as many matches.","category":"section"}]
}
